import {
  require_node,
  require_utils
} from "./chunk-RGCXGJCE.js";
import "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/sigma/rendering/webgl/shaders/node.image.vert.glsl.js
var require_node_image_vert_glsl = __commonJS({
  "node_modules/sigma/rendering/webgl/shaders/node.image.vert.glsl.js"(exports, module) {
    (() => {
      "use strict";
      var t = { d: (e2, n2) => {
        for (var o in n2) t.o(n2, o) && !t.o(e2, o) && Object.defineProperty(e2, o, { enumerable: true, get: n2[o] });
      }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      } }, e = {};
      t.r(e), t.d(e, { default: () => n });
      const n = "attribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\nattribute vec4 a_texture;\n\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\n\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n\n  // Pass the texture coordinates:\n  v_texture = a_texture;\n}\n";
      module.exports = e;
    })();
  }
});

// node_modules/sigma/rendering/webgl/shaders/node.image.frag.glsl.js
var require_node_image_frag_glsl = __commonJS({
  "node_modules/sigma/rendering/webgl/shaders/node.image.frag.glsl.js"(exports, module) {
    (() => {
      "use strict";
      var e = { d: (o2, r2) => {
        for (var n in r2) e.o(r2, n) && !e.o(o2, n) && Object.defineProperty(o2, n, { enumerable: true, get: r2[n] });
      }, o: (e2, o2) => Object.prototype.hasOwnProperty.call(e2, o2), r: (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, o = {};
      e.r(o), e.d(o, { default: () => r });
      const r = "precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nuniform sampler2D u_atlas;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec4 color;\n\n  if (v_texture.w > 0.0) {\n    vec4 texel = texture2D(u_atlas, v_texture.xy + gl_PointCoord * v_texture.zw, -1.0);\n    color = vec4(mix(v_color, texel, texel.a).rgb, max(texel.a, v_color.a));\n  } else {\n    color = v_color;\n  }\n\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = length(m);\n\n  if (dist < radius - v_border) {\n    gl_FragColor = color;\n  } else if (dist < radius) {\n    gl_FragColor = mix(transparent, color, (radius - dist) / v_border);\n  } else {\n    gl_FragColor = transparent;\n  }\n}\n";
      module.exports = o;
    })();
  }
});

// node_modules/sigma/rendering/webgl/programs/node.image.js
var require_node_image = __commonJS({
  "node_modules/sigma/rendering/webgl/programs/node.image.js"(exports) {
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var node_image_vert_glsl_1 = __importDefault(require_node_image_vert_glsl());
    var node_image_frag_glsl_1 = __importDefault(require_node_image_frag_glsl());
    var node_1 = require_node();
    var POINTS = 1;
    var ATTRIBUTES = 8;
    var MAX_TEXTURE_SIZE = 192;
    var MAX_CANVAS_WIDTH = 3072;
    var AbstractNodeImageProgram = (
      /** @class */
      function(_super) {
        __extends(AbstractNodeImageProgram2, _super);
        function AbstractNodeImageProgram2(gl, renderer) {
          return _super.call(this, gl, node_image_vert_glsl_1.default, node_image_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
        }
        AbstractNodeImageProgram2.prototype.bind = function() {
        };
        AbstractNodeImageProgram2.prototype.process = function(data, hidden, offset) {
        };
        AbstractNodeImageProgram2.prototype.render = function(params) {
        };
        AbstractNodeImageProgram2.prototype.rebindTexture = function() {
        };
        return AbstractNodeImageProgram2;
      }(node_1.AbstractNodeProgram)
    );
    function getNodeImageProgram() {
      var rebindTextureFns = [];
      var images = {};
      var textureImage;
      var hasReceivedImages = false;
      var pendingImagesFrameID = void 0;
      var writePositionX = 0;
      var writePositionY = 0;
      var writeRowHeight = 0;
      function loadImage(imageSource) {
        if (images[imageSource])
          return;
        var image = new Image();
        image.addEventListener("load", function() {
          images[imageSource] = {
            status: "pending",
            image
          };
          if (typeof pendingImagesFrameID !== "number") {
            pendingImagesFrameID = requestAnimationFrame(function() {
              return finalizePendingImages();
            });
          }
        });
        image.addEventListener("error", function() {
          images[imageSource] = { status: "error" };
        });
        images[imageSource] = { status: "loading" };
        image.setAttribute("crossOrigin", "");
        image.src = imageSource;
      }
      function finalizePendingImages() {
        pendingImagesFrameID = void 0;
        var pendingImages = [];
        for (var id in images) {
          var state = images[id];
          if (state.status === "pending") {
            pendingImages.push({
              id,
              image: state.image,
              size: Math.min(state.image.width, state.image.height) || 1
            });
          }
        }
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d", { willReadFrequently: true });
        var totalWidth = hasReceivedImages ? textureImage.width : 0;
        var totalHeight = hasReceivedImages ? textureImage.height : 0;
        var xOffset = writePositionX;
        var yOffset = writePositionY;
        var drawRow = function(pendingImages2) {
          if (canvas.width !== totalWidth || canvas.height !== totalHeight) {
            canvas.width = Math.min(MAX_CANVAS_WIDTH, totalWidth);
            canvas.height = totalHeight;
            if (hasReceivedImages) {
              ctx.putImageData(textureImage, 0, 0);
            }
          }
          pendingImages2.forEach(function(_a) {
            var id2 = _a.id, image = _a.image, size = _a.size;
            var imageSizeInTexture = Math.min(MAX_TEXTURE_SIZE, size);
            var dx = 0, dy = 0;
            if ((image.width || 0) > (image.height || 0)) {
              dx = (image.width - image.height) / 2;
            } else {
              dy = (image.height - image.width) / 2;
            }
            ctx.drawImage(image, dx, dy, size, size, xOffset, yOffset, imageSizeInTexture, imageSizeInTexture);
            images[id2] = {
              status: "ready",
              x: xOffset,
              y: yOffset,
              width: imageSizeInTexture,
              height: imageSizeInTexture
            };
            xOffset += imageSizeInTexture;
          });
          hasReceivedImages = true;
          textureImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
        };
        var rowImages = [];
        pendingImages.forEach(function(image) {
          var size = image.size;
          var imageSizeInTexture = Math.min(size, MAX_TEXTURE_SIZE);
          if (writePositionX + imageSizeInTexture > MAX_CANVAS_WIDTH) {
            if (rowImages.length > 0) {
              totalWidth = Math.max(writePositionX, totalWidth);
              totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
              drawRow(rowImages);
              rowImages = [];
              writeRowHeight = 0;
            }
            writePositionX = 0;
            writePositionY = totalHeight;
            xOffset = 0;
            yOffset = totalHeight;
          }
          rowImages.push(image);
          writePositionX += imageSizeInTexture;
          writeRowHeight = Math.max(writeRowHeight, imageSizeInTexture);
        });
        totalWidth = Math.max(writePositionX, totalWidth);
        totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
        drawRow(rowImages);
        rowImages = [];
        rebindTextureFns.forEach(function(fn) {
          return fn();
        });
      }
      return (
        /** @class */
        function(_super) {
          __extends(NodeImageProgram, _super);
          function NodeImageProgram(gl, renderer) {
            var _this = _super.call(this, gl, node_image_vert_glsl_1.default, node_image_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
            rebindTextureFns.push(function() {
              if (_this && _this.rebindTexture)
                _this.rebindTexture();
              if (renderer && renderer.refresh)
                renderer.refresh();
            });
            textureImage = new ImageData(1, 1);
            _this.textureLocation = gl.getAttribLocation(_this.program, "a_texture");
            var atlasLocation = gl.getUniformLocation(_this.program, "u_atlas");
            if (atlasLocation === null)
              throw new Error("NodeProgramImage: error while getting atlasLocation");
            _this.atlasLocation = atlasLocation;
            _this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, _this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));
            _this.bind();
            return _this;
          }
          NodeImageProgram.prototype.bind = function() {
            _super.prototype.bind.call(this);
            var gl = this.gl;
            gl.enableVertexAttribArray(this.textureLocation);
            gl.vertexAttribPointer(this.textureLocation, 4, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 16);
          };
          NodeImageProgram.prototype.process = function(data, hidden, offset) {
            var array = this.array;
            var i = offset * POINTS * ATTRIBUTES;
            var imageSource = data.image;
            var imageState = imageSource && images[imageSource];
            if (typeof imageSource === "string" && !imageState)
              loadImage(imageSource);
            if (hidden) {
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              return;
            }
            array[i++] = data.x;
            array[i++] = data.y;
            array[i++] = data.size;
            array[i++] = (0, utils_1.floatColor)(data.color);
            if (imageState && imageState.status === "ready") {
              var width = textureImage.width, height = textureImage.height;
              array[i++] = imageState.x / width;
              array[i++] = imageState.y / height;
              array[i++] = imageState.width / width;
              array[i++] = imageState.height / height;
            } else {
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
              array[i++] = 0;
            }
          };
          NodeImageProgram.prototype.render = function(params) {
            if (this.hasNothingToRender())
              return;
            this.latestRenderParams = params;
            var gl = this.gl;
            var program = this.program;
            gl.useProgram(program);
            gl.uniform1f(this.ratioLocation, 1 / Math.sqrt(params.ratio));
            gl.uniform1f(this.scaleLocation, params.scalingRatio);
            gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
            gl.uniform1i(this.atlasLocation, 0);
            gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);
          };
          NodeImageProgram.prototype.rebindTexture = function() {
            var gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
            gl.generateMipmap(gl.TEXTURE_2D);
            if (this.latestRenderParams) {
              this.bind();
              this.bufferData();
              this.render(this.latestRenderParams);
            }
          };
          return NodeImageProgram;
        }(node_1.AbstractNodeProgram)
      );
    }
    exports.default = getNodeImageProgram;
  }
});
export default require_node_image();
//# sourceMappingURL=sigma_rendering_webgl_programs_node__image.js.map
