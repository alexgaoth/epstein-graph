{
  "version": 3,
  "sources": ["../../sigma/rendering/webgl/shaders/node.image.vert.glsl.js", "../../sigma/rendering/webgl/shaders/node.image.frag.glsl.js", "../../sigma/rendering/webgl/programs/node.image.js"],
  "sourcesContent": ["(()=>{\"use strict\";var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})}},e={};t.r(e),t.d(e,{default:()=>n});const n=\"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\nattribute vec4 a_texture;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\nvarying vec4 v_texture;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n\\n  // Pass the texture coordinates:\\n  v_texture = a_texture;\\n}\\n\";module.exports=e})();", "(()=>{\"use strict\";var e={d:(o,r)=>{for(var n in r)e.o(r,n)&&!e.o(o,n)&&Object.defineProperty(o,n,{enumerable:!0,get:r[n]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>r});const r=\"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\nvarying vec4 v_texture;\\n\\nuniform sampler2D u_atlas;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec4 color;\\n\\n  if (v_texture.w > 0.0) {\\n    vec4 texel = texture2D(u_atlas, v_texture.xy + gl_PointCoord * v_texture.zw, -1.0);\\n    color = vec4(mix(v_color, texel, texel.a).rgb, max(texel.a, v_color.a));\\n  } else {\\n    color = v_color;\\n  }\\n\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = length(m);\\n\\n  if (dist < radius - v_border) {\\n    gl_FragColor = color;\\n  } else if (dist < radius) {\\n    gl_FragColor = mix(transparent, color, (radius - dist) / v_border);\\n  } else {\\n    gl_FragColor = transparent;\\n  }\\n}\\n\";module.exports=o})();", "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../../utils\");\nvar node_image_vert_glsl_1 = __importDefault(require(\"../shaders/node.image.vert.glsl.js\"));\nvar node_image_frag_glsl_1 = __importDefault(require(\"../shaders/node.image.frag.glsl.js\"));\nvar node_1 = require(\"./common/node\");\nvar POINTS = 1, ATTRIBUTES = 8, \n// maximum size of single texture in atlas\nMAX_TEXTURE_SIZE = 192, \n// maximum width of atlas texture (limited by browser)\n// low setting of 3072 works on phones & tablets\nMAX_CANVAS_WIDTH = 3072;\n// This class only exists for the return typing of `getNodeImageProgram`:\nvar AbstractNodeImageProgram = /** @class */ (function (_super) {\n    __extends(AbstractNodeImageProgram, _super);\n    /* eslint-disable @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars */\n    function AbstractNodeImageProgram(gl, renderer) {\n        return _super.call(this, gl, node_image_vert_glsl_1.default, node_image_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n    }\n    AbstractNodeImageProgram.prototype.bind = function () { };\n    AbstractNodeImageProgram.prototype.process = function (data, hidden, offset) { };\n    AbstractNodeImageProgram.prototype.render = function (params) { };\n    AbstractNodeImageProgram.prototype.rebindTexture = function () { };\n    return AbstractNodeImageProgram;\n}(node_1.AbstractNodeProgram));\n/**\n * To share the texture between the program instances of the graph and the\n * hovered nodes (to prevent some flickering, mostly), this program must be\n * \"built\" for each sigma instance:\n */\nfunction getNodeImageProgram() {\n    /**\n     * These attributes are shared between all instances of this exact class,\n     * returned by this call to getNodeProgramImage:\n     */\n    var rebindTextureFns = [];\n    var images = {};\n    var textureImage;\n    var hasReceivedImages = false;\n    var pendingImagesFrameID = undefined;\n    // next write position in texture\n    var writePositionX = 0;\n    var writePositionY = 0;\n    // height of current row\n    var writeRowHeight = 0;\n    /**\n     * Helper to load an image:\n     */\n    function loadImage(imageSource) {\n        if (images[imageSource])\n            return;\n        var image = new Image();\n        image.addEventListener(\"load\", function () {\n            images[imageSource] = {\n                status: \"pending\",\n                image: image,\n            };\n            if (typeof pendingImagesFrameID !== \"number\") {\n                pendingImagesFrameID = requestAnimationFrame(function () { return finalizePendingImages(); });\n            }\n        });\n        image.addEventListener(\"error\", function () {\n            images[imageSource] = { status: \"error\" };\n        });\n        images[imageSource] = { status: \"loading\" };\n        // Load image:\n        image.setAttribute(\"crossOrigin\", \"\");\n        image.src = imageSource;\n    }\n    /**\n     * Helper that takes all pending images and adds them into the texture:\n     */\n    function finalizePendingImages() {\n        pendingImagesFrameID = undefined;\n        var pendingImages = [];\n        // List all pending images:\n        for (var id in images) {\n            var state = images[id];\n            if (state.status === \"pending\") {\n                pendingImages.push({\n                    id: id,\n                    image: state.image,\n                    size: Math.min(state.image.width, state.image.height) || 1,\n                });\n            }\n        }\n        // Add images to texture:\n        var canvas = document.createElement(\"canvas\");\n        var ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n        // limit canvas size to avoid browser and platform limits\n        var totalWidth = hasReceivedImages ? textureImage.width : 0;\n        var totalHeight = hasReceivedImages ? textureImage.height : 0;\n        // initialize image drawing offsets with current write position\n        var xOffset = writePositionX;\n        var yOffset = writePositionY;\n        /**\n         * Draws a (full or partial) row of images into the atlas texture\n         * @param pendingImages\n         */\n        var drawRow = function (pendingImages) {\n            // update canvas size before drawing\n            if (canvas.width !== totalWidth || canvas.height !== totalHeight) {\n                canvas.width = Math.min(MAX_CANVAS_WIDTH, totalWidth);\n                canvas.height = totalHeight;\n                // draw previous texture into resized canvas\n                if (hasReceivedImages) {\n                    ctx.putImageData(textureImage, 0, 0);\n                }\n            }\n            pendingImages.forEach(function (_a) {\n                var id = _a.id, image = _a.image, size = _a.size;\n                var imageSizeInTexture = Math.min(MAX_TEXTURE_SIZE, size);\n                // Crop image, to only keep the biggest square, centered:\n                var dx = 0, dy = 0;\n                if ((image.width || 0) > (image.height || 0)) {\n                    dx = (image.width - image.height) / 2;\n                }\n                else {\n                    dy = (image.height - image.width) / 2;\n                }\n                ctx.drawImage(image, dx, dy, size, size, xOffset, yOffset, imageSizeInTexture, imageSizeInTexture);\n                // Update image state:\n                images[id] = {\n                    status: \"ready\",\n                    x: xOffset,\n                    y: yOffset,\n                    width: imageSizeInTexture,\n                    height: imageSizeInTexture,\n                };\n                xOffset += imageSizeInTexture;\n            });\n            hasReceivedImages = true;\n            textureImage = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        };\n        var rowImages = [];\n        pendingImages.forEach(function (image) {\n            var size = image.size;\n            var imageSizeInTexture = Math.min(size, MAX_TEXTURE_SIZE);\n            if (writePositionX + imageSizeInTexture > MAX_CANVAS_WIDTH) {\n                // existing row is full: flush row and continue on next line\n                if (rowImages.length > 0) {\n                    totalWidth = Math.max(writePositionX, totalWidth);\n                    totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);\n                    drawRow(rowImages);\n                    rowImages = [];\n                    writeRowHeight = 0;\n                }\n                writePositionX = 0;\n                writePositionY = totalHeight;\n                xOffset = 0;\n                yOffset = totalHeight;\n            }\n            // add image to row\n            rowImages.push(image);\n            // advance write position and update maximum row height\n            writePositionX += imageSizeInTexture;\n            writeRowHeight = Math.max(writeRowHeight, imageSizeInTexture);\n        });\n        // flush pending images in row - keep write position (and drawing cursor)\n        totalWidth = Math.max(writePositionX, totalWidth);\n        totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);\n        drawRow(rowImages);\n        rowImages = [];\n        rebindTextureFns.forEach(function (fn) { return fn(); });\n    }\n    return /** @class */ (function (_super) {\n        __extends(NodeImageProgram, _super);\n        function NodeImageProgram(gl, renderer) {\n            var _this = _super.call(this, gl, node_image_vert_glsl_1.default, node_image_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n            rebindTextureFns.push(function () {\n                if (_this && _this.rebindTexture)\n                    _this.rebindTexture();\n                if (renderer && renderer.refresh)\n                    renderer.refresh();\n            });\n            textureImage = new ImageData(1, 1);\n            // Attribute Location\n            _this.textureLocation = gl.getAttribLocation(_this.program, \"a_texture\");\n            // Uniform Location\n            var atlasLocation = gl.getUniformLocation(_this.program, \"u_atlas\");\n            if (atlasLocation === null)\n                throw new Error(\"NodeProgramImage: error while getting atlasLocation\");\n            _this.atlasLocation = atlasLocation;\n            // Initialize WebGL texture:\n            _this.texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, _this.texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n            _this.bind();\n            return _this;\n        }\n        NodeImageProgram.prototype.bind = function () {\n            _super.prototype.bind.call(this);\n            var gl = this.gl;\n            gl.enableVertexAttribArray(this.textureLocation);\n            gl.vertexAttribPointer(this.textureLocation, 4, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 16);\n        };\n        NodeImageProgram.prototype.process = function (data, hidden, offset) {\n            var array = this.array;\n            var i = offset * POINTS * ATTRIBUTES;\n            var imageSource = data.image;\n            var imageState = imageSource && images[imageSource];\n            if (typeof imageSource === \"string\" && !imageState)\n                loadImage(imageSource);\n            if (hidden) {\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n                // Texture:\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n                return;\n            }\n            array[i++] = data.x;\n            array[i++] = data.y;\n            array[i++] = data.size;\n            array[i++] = (0, utils_1.floatColor)(data.color);\n            // Reference texture:\n            if (imageState && imageState.status === \"ready\") {\n                var width = textureImage.width, height = textureImage.height;\n                array[i++] = imageState.x / width;\n                array[i++] = imageState.y / height;\n                array[i++] = imageState.width / width;\n                array[i++] = imageState.height / height;\n            }\n            else {\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n                array[i++] = 0;\n            }\n        };\n        NodeImageProgram.prototype.render = function (params) {\n            if (this.hasNothingToRender())\n                return;\n            this.latestRenderParams = params;\n            var gl = this.gl;\n            var program = this.program;\n            gl.useProgram(program);\n            gl.uniform1f(this.ratioLocation, 1 / Math.sqrt(params.ratio));\n            gl.uniform1f(this.scaleLocation, params.scalingRatio);\n            gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n            gl.uniform1i(this.atlasLocation, 0);\n            gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);\n        };\n        NodeImageProgram.prototype.rebindTexture = function () {\n            var gl = this.gl;\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n            gl.generateMipmap(gl.TEXTURE_2D);\n            if (this.latestRenderParams) {\n                this.bind();\n                this.bufferData();\n                this.render(this.latestRenderParams);\n            }\n        };\n        return NodeImageProgram;\n    }(node_1.AbstractNodeProgram));\n}\nexports.default = getNodeImageProgram;\n"],
  "mappings": ";;;;;;;;;;AAAA;AAAA;AAAA,KAAC,MAAI;AAAC;AAAa,UAAI,IAAE,EAAC,GAAE,CAACA,IAAEC,OAAI;AAAC,iBAAQ,KAAKA,GAAE,GAAE,EAAEA,IAAE,CAAC,KAAG,CAAC,EAAE,EAAED,IAAE,CAAC,KAAG,OAAO,eAAeA,IAAE,GAAE,EAAC,YAAW,MAAG,KAAIC,GAAE,CAAC,EAAC,CAAC;AAAA,MAAC,GAAE,GAAE,CAACC,IAAEF,OAAI,OAAO,UAAU,eAAe,KAAKE,IAAEF,EAAC,GAAE,GAAE,CAAAE,OAAG;AAAC,uBAAa,OAAO,UAAQ,OAAO,eAAa,OAAO,eAAeA,IAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,GAAE,OAAO,eAAeA,IAAE,cAAa,EAAC,OAAM,KAAE,CAAC;AAAA,MAAC,EAAC,GAAE,IAAE,CAAC;AAAE,QAAE,EAAE,CAAC,GAAE,EAAE,EAAE,GAAE,EAAC,SAAQ,MAAI,EAAC,CAAC;AAAE,YAAM,IAAE;AAAgwB,aAAO,UAAQ;AAAA,IAAC,GAAG;AAAA;AAAA;;;ACAppC;AAAA;AAAA,KAAC,MAAI;AAAC;AAAa,UAAI,IAAE,EAAC,GAAE,CAACC,IAAEC,OAAI;AAAC,iBAAQ,KAAKA,GAAE,GAAE,EAAEA,IAAE,CAAC,KAAG,CAAC,EAAE,EAAED,IAAE,CAAC,KAAG,OAAO,eAAeA,IAAE,GAAE,EAAC,YAAW,MAAG,KAAIC,GAAE,CAAC,EAAC,CAAC;AAAA,MAAC,GAAE,GAAE,CAACC,IAAEF,OAAI,OAAO,UAAU,eAAe,KAAKE,IAAEF,EAAC,GAAE,GAAE,CAAAE,OAAG;AAAC,uBAAa,OAAO,UAAQ,OAAO,eAAa,OAAO,eAAeA,IAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,GAAE,OAAO,eAAeA,IAAE,cAAa,EAAC,OAAM,KAAE,CAAC;AAAA,MAAC,EAAC,GAAE,IAAE,CAAC;AAAE,QAAE,EAAE,CAAC,GAAE,EAAE,EAAE,GAAE,EAAC,SAAQ,MAAI,EAAC,CAAC;AAAE,YAAM,IAAE;AAA6wB,aAAO,UAAQ;AAAA,IAAC,GAAG;AAAA;AAAA;;;ACAjqC;AAAA;AACA,QAAI,YAAa,WAAQ,QAAK,aAAe,2BAAY;AACrD,UAAI,gBAAgB,SAAU,GAAG,GAAG;AAChC,wBAAgB,OAAO,kBAClB,EAAE,WAAW,CAAC,EAAE,aAAa,SAAS,SAAUC,IAAGC,IAAG;AAAE,UAAAD,GAAE,YAAYC;AAAA,QAAG,KAC1E,SAAUD,IAAGC,IAAG;AAAE,mBAAS,KAAKA,GAAG,KAAI,OAAO,UAAU,eAAe,KAAKA,IAAG,CAAC,EAAG,CAAAD,GAAE,CAAC,IAAIC,GAAE,CAAC;AAAA,QAAG;AACpG,eAAO,cAAc,GAAG,CAAC;AAAA,MAC7B;AACA,aAAO,SAAU,GAAG,GAAG;AACnB,YAAI,OAAO,MAAM,cAAc,MAAM;AACjC,gBAAM,IAAI,UAAU,yBAAyB,OAAO,CAAC,IAAI,+BAA+B;AAC5F,sBAAc,GAAG,CAAC;AAClB,iBAAS,KAAK;AAAE,eAAK,cAAc;AAAA,QAAG;AACtC,UAAE,YAAY,MAAM,OAAO,OAAO,OAAO,CAAC,KAAK,GAAG,YAAY,EAAE,WAAW,IAAI,GAAG;AAAA,MACtF;AAAA,IACJ,EAAG;AACH,QAAI,kBAAmB,WAAQ,QAAK,mBAAoB,SAAU,KAAK;AACnE,aAAQ,OAAO,IAAI,aAAc,MAAM,EAAE,WAAW,IAAI;AAAA,IAC5D;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,QAAI,UAAU;AACd,QAAI,yBAAyB,gBAAgB,8BAA6C;AAC1F,QAAI,yBAAyB,gBAAgB,8BAA6C;AAC1F,QAAI,SAAS;AACb,QAAI,SAAS;AAAb,QAAgB,aAAa;AAA7B,QAEA,mBAAmB;AAFnB,QAKA,mBAAmB;AAEnB,QAAI;AAAA;AAAA,MAA0C,SAAU,QAAQ;AAC5D,kBAAUC,2BAA0B,MAAM;AAE1C,iBAASA,0BAAyB,IAAI,UAAU;AAC5C,iBAAO,OAAO,KAAK,MAAM,IAAI,uBAAuB,SAAS,uBAAuB,SAAS,QAAQ,UAAU,KAAK;AAAA,QACxH;AACA,QAAAA,0BAAyB,UAAU,OAAO,WAAY;AAAA,QAAE;AACxD,QAAAA,0BAAyB,UAAU,UAAU,SAAU,MAAM,QAAQ,QAAQ;AAAA,QAAE;AAC/E,QAAAA,0BAAyB,UAAU,SAAS,SAAU,QAAQ;AAAA,QAAE;AAChE,QAAAA,0BAAyB,UAAU,gBAAgB,WAAY;AAAA,QAAE;AACjE,eAAOA;AAAA,MACX,EAAE,OAAO,mBAAmB;AAAA;AAM5B,aAAS,sBAAsB;AAK3B,UAAI,mBAAmB,CAAC;AACxB,UAAI,SAAS,CAAC;AACd,UAAI;AACJ,UAAI,oBAAoB;AACxB,UAAI,uBAAuB;AAE3B,UAAI,iBAAiB;AACrB,UAAI,iBAAiB;AAErB,UAAI,iBAAiB;AAIrB,eAAS,UAAU,aAAa;AAC5B,YAAI,OAAO,WAAW;AAClB;AACJ,YAAI,QAAQ,IAAI,MAAM;AACtB,cAAM,iBAAiB,QAAQ,WAAY;AACvC,iBAAO,WAAW,IAAI;AAAA,YAClB,QAAQ;AAAA,YACR;AAAA,UACJ;AACA,cAAI,OAAO,yBAAyB,UAAU;AAC1C,mCAAuB,sBAAsB,WAAY;AAAE,qBAAO,sBAAsB;AAAA,YAAG,CAAC;AAAA,UAChG;AAAA,QACJ,CAAC;AACD,cAAM,iBAAiB,SAAS,WAAY;AACxC,iBAAO,WAAW,IAAI,EAAE,QAAQ,QAAQ;AAAA,QAC5C,CAAC;AACD,eAAO,WAAW,IAAI,EAAE,QAAQ,UAAU;AAE1C,cAAM,aAAa,eAAe,EAAE;AACpC,cAAM,MAAM;AAAA,MAChB;AAIA,eAAS,wBAAwB;AAC7B,+BAAuB;AACvB,YAAI,gBAAgB,CAAC;AAErB,iBAAS,MAAM,QAAQ;AACnB,cAAI,QAAQ,OAAO,EAAE;AACrB,cAAI,MAAM,WAAW,WAAW;AAC5B,0BAAc,KAAK;AAAA,cACf;AAAA,cACA,OAAO,MAAM;AAAA,cACb,MAAM,KAAK,IAAI,MAAM,MAAM,OAAO,MAAM,MAAM,MAAM,KAAK;AAAA,YAC7D,CAAC;AAAA,UACL;AAAA,QACJ;AAEA,YAAI,SAAS,SAAS,cAAc,QAAQ;AAC5C,YAAI,MAAM,OAAO,WAAW,MAAM,EAAE,oBAAoB,KAAK,CAAC;AAE9D,YAAI,aAAa,oBAAoB,aAAa,QAAQ;AAC1D,YAAI,cAAc,oBAAoB,aAAa,SAAS;AAE5D,YAAI,UAAU;AACd,YAAI,UAAU;AAKd,YAAI,UAAU,SAAUC,gBAAe;AAEnC,cAAI,OAAO,UAAU,cAAc,OAAO,WAAW,aAAa;AAC9D,mBAAO,QAAQ,KAAK,IAAI,kBAAkB,UAAU;AACpD,mBAAO,SAAS;AAEhB,gBAAI,mBAAmB;AACnB,kBAAI,aAAa,cAAc,GAAG,CAAC;AAAA,YACvC;AAAA,UACJ;AACA,UAAAA,eAAc,QAAQ,SAAU,IAAI;AAChC,gBAAIC,MAAK,GAAG,IAAI,QAAQ,GAAG,OAAO,OAAO,GAAG;AAC5C,gBAAI,qBAAqB,KAAK,IAAI,kBAAkB,IAAI;AAExD,gBAAI,KAAK,GAAG,KAAK;AACjB,iBAAK,MAAM,SAAS,MAAM,MAAM,UAAU,IAAI;AAC1C,oBAAM,MAAM,QAAQ,MAAM,UAAU;AAAA,YACxC,OACK;AACD,oBAAM,MAAM,SAAS,MAAM,SAAS;AAAA,YACxC;AACA,gBAAI,UAAU,OAAO,IAAI,IAAI,MAAM,MAAM,SAAS,SAAS,oBAAoB,kBAAkB;AAEjG,mBAAOA,GAAE,IAAI;AAAA,cACT,QAAQ;AAAA,cACR,GAAG;AAAA,cACH,GAAG;AAAA,cACH,OAAO;AAAA,cACP,QAAQ;AAAA,YACZ;AACA,uBAAW;AAAA,UACf,CAAC;AACD,8BAAoB;AACpB,yBAAe,IAAI,aAAa,GAAG,GAAG,OAAO,OAAO,OAAO,MAAM;AAAA,QACrE;AACA,YAAI,YAAY,CAAC;AACjB,sBAAc,QAAQ,SAAU,OAAO;AACnC,cAAI,OAAO,MAAM;AACjB,cAAI,qBAAqB,KAAK,IAAI,MAAM,gBAAgB;AACxD,cAAI,iBAAiB,qBAAqB,kBAAkB;AAExD,gBAAI,UAAU,SAAS,GAAG;AACtB,2BAAa,KAAK,IAAI,gBAAgB,UAAU;AAChD,4BAAc,KAAK,IAAI,iBAAiB,gBAAgB,WAAW;AACnE,sBAAQ,SAAS;AACjB,0BAAY,CAAC;AACb,+BAAiB;AAAA,YACrB;AACA,6BAAiB;AACjB,6BAAiB;AACjB,sBAAU;AACV,sBAAU;AAAA,UACd;AAEA,oBAAU,KAAK,KAAK;AAEpB,4BAAkB;AAClB,2BAAiB,KAAK,IAAI,gBAAgB,kBAAkB;AAAA,QAChE,CAAC;AAED,qBAAa,KAAK,IAAI,gBAAgB,UAAU;AAChD,sBAAc,KAAK,IAAI,iBAAiB,gBAAgB,WAAW;AACnE,gBAAQ,SAAS;AACjB,oBAAY,CAAC;AACb,yBAAiB,QAAQ,SAAU,IAAI;AAAE,iBAAO,GAAG;AAAA,QAAG,CAAC;AAAA,MAC3D;AACA;AAAA;AAAA,QAAsB,SAAU,QAAQ;AACpC,oBAAU,kBAAkB,MAAM;AAClC,mBAAS,iBAAiB,IAAI,UAAU;AACpC,gBAAI,QAAQ,OAAO,KAAK,MAAM,IAAI,uBAAuB,SAAS,uBAAuB,SAAS,QAAQ,UAAU,KAAK;AACzH,6BAAiB,KAAK,WAAY;AAC9B,kBAAI,SAAS,MAAM;AACf,sBAAM,cAAc;AACxB,kBAAI,YAAY,SAAS;AACrB,yBAAS,QAAQ;AAAA,YACzB,CAAC;AACD,2BAAe,IAAI,UAAU,GAAG,CAAC;AAEjC,kBAAM,kBAAkB,GAAG,kBAAkB,MAAM,SAAS,WAAW;AAEvE,gBAAI,gBAAgB,GAAG,mBAAmB,MAAM,SAAS,SAAS;AAClE,gBAAI,kBAAkB;AAClB,oBAAM,IAAI,MAAM,qDAAqD;AACzE,kBAAM,gBAAgB;AAEtB,kBAAM,UAAU,GAAG,cAAc;AACjC,eAAG,YAAY,GAAG,YAAY,MAAM,OAAO;AAC3C,eAAG,WAAW,GAAG,YAAY,GAAG,GAAG,MAAM,GAAG,GAAG,GAAG,GAAG,MAAM,GAAG,eAAe,IAAI,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AACzG,kBAAM,KAAK;AACX,mBAAO;AAAA,UACX;AACA,2BAAiB,UAAU,OAAO,WAAY;AAC1C,mBAAO,UAAU,KAAK,KAAK,IAAI;AAC/B,gBAAI,KAAK,KAAK;AACd,eAAG,wBAAwB,KAAK,eAAe;AAC/C,eAAG,oBAAoB,KAAK,iBAAiB,GAAG,GAAG,OAAO,OAAO,KAAK,aAAa,aAAa,mBAAmB,EAAE;AAAA,UACzH;AACA,2BAAiB,UAAU,UAAU,SAAU,MAAM,QAAQ,QAAQ;AACjE,gBAAI,QAAQ,KAAK;AACjB,gBAAI,IAAI,SAAS,SAAS;AAC1B,gBAAI,cAAc,KAAK;AACvB,gBAAI,aAAa,eAAe,OAAO,WAAW;AAClD,gBAAI,OAAO,gBAAgB,YAAY,CAAC;AACpC,wBAAU,WAAW;AACzB,gBAAI,QAAQ;AACR,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AAEb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb;AAAA,YACJ;AACA,kBAAM,GAAG,IAAI,KAAK;AAClB,kBAAM,GAAG,IAAI,KAAK;AAClB,kBAAM,GAAG,IAAI,KAAK;AAClB,kBAAM,GAAG,KAAK,GAAG,QAAQ,YAAY,KAAK,KAAK;AAE/C,gBAAI,cAAc,WAAW,WAAW,SAAS;AAC7C,kBAAI,QAAQ,aAAa,OAAO,SAAS,aAAa;AACtD,oBAAM,GAAG,IAAI,WAAW,IAAI;AAC5B,oBAAM,GAAG,IAAI,WAAW,IAAI;AAC5B,oBAAM,GAAG,IAAI,WAAW,QAAQ;AAChC,oBAAM,GAAG,IAAI,WAAW,SAAS;AAAA,YACrC,OACK;AACD,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AACb,oBAAM,GAAG,IAAI;AAAA,YACjB;AAAA,UACJ;AACA,2BAAiB,UAAU,SAAS,SAAU,QAAQ;AAClD,gBAAI,KAAK,mBAAmB;AACxB;AACJ,iBAAK,qBAAqB;AAC1B,gBAAI,KAAK,KAAK;AACd,gBAAI,UAAU,KAAK;AACnB,eAAG,WAAW,OAAO;AACrB,eAAG,UAAU,KAAK,eAAe,IAAI,KAAK,KAAK,OAAO,KAAK,CAAC;AAC5D,eAAG,UAAU,KAAK,eAAe,OAAO,YAAY;AACpD,eAAG,iBAAiB,KAAK,gBAAgB,OAAO,OAAO,MAAM;AAC7D,eAAG,UAAU,KAAK,eAAe,CAAC;AAClC,eAAG,WAAW,GAAG,QAAQ,GAAG,KAAK,MAAM,SAAS,UAAU;AAAA,UAC9D;AACA,2BAAiB,UAAU,gBAAgB,WAAY;AACnD,gBAAI,KAAK,KAAK;AACd,eAAG,YAAY,GAAG,YAAY,KAAK,OAAO;AAC1C,eAAG,WAAW,GAAG,YAAY,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,eAAe,YAAY;AAChF,eAAG,eAAe,GAAG,UAAU;AAC/B,gBAAI,KAAK,oBAAoB;AACzB,mBAAK,KAAK;AACV,mBAAK,WAAW;AAChB,mBAAK,OAAO,KAAK,kBAAkB;AAAA,YACvC;AAAA,UACJ;AACA,iBAAO;AAAA,QACX,EAAE,OAAO,mBAAmB;AAAA;AAAA,IAChC;AACA,YAAQ,UAAU;AAAA;AAAA;",
  "names": ["e", "n", "t", "o", "r", "e", "d", "b", "AbstractNodeImageProgram", "pendingImages", "id"]
}
